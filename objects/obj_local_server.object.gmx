<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_ctrl</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup the object

/*
This object should only exist on the server machine and stores the socket ID of the server
(returned by the `create_server()`)
*/

server_id = noone;

// Create the clients list, ready for `NET_MAX_CLIENTS` number of clients
for(var i = 0; i &lt; NET_MAX_CLIENTS; i++) {
    clients_list[i] = noone;
}

send_buffer = buffer_create(1024, buffer_fixed, 1);

// This starts the alarm that runs once a second to check for a client timeout
// e.g a message from the client has not been recieved for 5 seconds or more.
alarm[0] = room_speed;

alarm[1] = room_speed * (1 / NET_CLIENT_UPDATE_SPD);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>network_destroy(self.server_id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for(var i = 0; i &lt; array_length_1d(self.clients_list); i++) {
    if(self.clients_list[i] != noone) {
        self.send_buffer = prepare_packet_buffer(self.send_buffer, NET_PCK_DATA);
        
        network_send_udp_raw(self.server_id, self.clients_list[i].client_ip, self.clients_list[i].client_port, self.send_buffer, 6);
    }
}

alarm[1] = room_speed * (1 / NET_CLIENT_UPDATE_SPD);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clients timeout handler

// Should run once a second.

for(var i = 0; i &lt; array_length_1d(self.clients_list); i++) {
    var client = self.clients_list[i];
    
    if(client != noone) {
        client.time_since_last_packet = client.time_since_last_packet + 1;
        if(client.time_since_last_packet &gt;= NET_TIMEOUT_SECONDS) {
            debug_message("Client disconnected - port: " + string(client.client_port));
            server_remove_client(self, i);
        }
    }
}

alarm[0] = room_speed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// The socket that is recieving the data (aka the socket the server is on)
var socket_id = ds_map_find_value(async_load, "id");

if(socket_id == self.server_id) {
    var type = ds_map_find_value(async_load, "type");
    switch(type) {
    case network_type_data:
        var in_buffer = async_load[? "buffer"];
        var header_uid = buffer_read(in_buffer, buffer_u32);
        
        // Only process packets intented for us
        if(header_uid == NET_PACKET_UID) {
            var client_ip = async_load[? "ip"];
            var client_port = async_load[? "port"]; 
            
            var packet_type = buffer_read(in_buffer, buffer_u16);
            switch(packet_type) {
            case NET_PCK_DATA:
                var i = server_find_client_slot(self, client_ip);
                var client = self.clients_list[i];
                client.time_since_last_packet = 0;
                break;
            case NET_PCK_CONNECTION_DISCONNECT:
                var client_index = server_find_client_slot(self, client_ip);
                if(self.clients_list[client_index] != noone) {
                    server_remove_client(self, client_index);
                    debug_message("Clean disconnect for client: " + string(client_index));
                }
                break;
            case NET_PCK_CONNECTION_REQUEST:
                var i = server_find_client_slot(self, client_ip);
                
                // Determine the type of response we will be sending back to the client
                // e.g. If there is free space in the clients array (or the client is already in the array)
                // then accept the request, otherwise reject it.
                var msg_type = NET_PCK_CONNECTION_ACCEPTED;
                
                if(i &gt;= 0) {
                    // This is taking into account that we may have already created the client object
                    // (remembering that if the incoming client is already in the array then we should still return
                    //  NET_PCK_CONNECTION_ACCEPTED)
                    if(self.clients_list[i] == noone) {
                        var client_obj = create_object(obj_server_client);
                        
                        // Because we just use the `obj_server_client` objects for data storage, its faster to deactivate them
                        // https://www.reddit.com/r/gamemaker/comments/3zhar3/would_using_objects_be_more_efficient_than_ds_maps/cymdy9v/
                        instance_deactivate_object(client_obj);
                        
                        client_obj.client_ip = client_ip;
                        client_obj.client_port = client_port;
                        self.clients_list[i] = client_obj;
                        
                        debug_message("Server: Client connected!");
                    }
                } else {
                    msg_type = NET_PCK_CONNECTION_REJECTED;
                    debug_message("Server: Client rejected!");
                }
                                
                self.send_buffer = prepare_packet_buffer(self.send_buffer, msg_type);
                
                // Lets just send this packet 5 times to increase the chances that one packet gets through.
                // TODO: We should probably handle this situation properly.
                repeat(5) {
                    network_send_udp_raw(self.server_id, client_ip, client_port, self.send_buffer, 6);
                }
                break;
            }
        }
        
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>network_destroy(self.server_id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
